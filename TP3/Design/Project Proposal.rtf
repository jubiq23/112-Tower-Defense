{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww16600\viewh17700\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Project Proposal:\
\
	Project Description - I\'92m making my own take on the game, Bloons Tower Defense. I\'92m calling it 112 Tower Defense (so original!). Essentially, the way the game will work is that balloons will move down a path (eventually, I think this path will be random generated. At the moment, it\'92s hardcoded). As balloons move down the path, turrets that you can purchase using cash are placed off the track, and these turrets (each with their own features) will attack the balloons and pop them before they reach the end of the track. If they reach the end, you lose health points. Health points reach zero, game over. Otherwise, the game will continue. The game will continue arcade style until the player either gives up or loses: but as the game progresses, the balloons get more and more tough, move faster, and present more of a challenge. You can also upgrade the turrets to increase their attack speed and damage level on the balloons.\
\
	Competitive Analysis - My project is very much based on the existing Bloons Tower Defense by Ninjakiwi games. It also resembles many similar tower defense games that exist online. The biggest similarities are that turrets are placed in spaces that they are designated for, and objects that enter through the track are attacked once they enter the range of each turret. The turrets that are in my game resemble the ones in the game by Ninjakiwi: for example, the standard dart shooter, or the cannon.\
	However, there are many differences in my take on the game. At the moment, the largest difference is that I intend on having paths be randomly generated, as opposed to preloaded. These paths will be generated to be relatively complex. Different types of curves will be in a predetermined list and the generator will pull from those to make an interesting and complex path each time.\
\
	Structural Plan - The player, balloons, and the various turrets each exist as their own class, and separate lists of the balloons in game as well as the turrets on board exist. Each time a turret is purchased, that variant of the turret is drawn on the board, but a class instance of that turret is added to a list of turrets with all parameters. When upgrading turrets, once one is selected, the specific object parameters of that instance are modified, with the expense of cash. At the moment, the turrets are purchased using 1,2, and 3 on the keyboard and mouse cursor, but this will eventually be neater with a proper mouse click selection menu. \
	The path is drawn by connecting the dots. At the moment, you specify points on the app window and these points are connected to form a path. As levels progress, the game will append balloons to a list of balloons and when they enter the range specified of a turret, a function that is constantly running to check this event will trigger the turret to start attacking at the balloon. This will cause its health parameter to drop, until the balloon pops.\
	As each \'93level\'94 goes on (this is based on how much time has elapsed, most likely), the balloons will progressively get stronger and faster. \
	I might add a class for all the buttons in the game, but this will be after I can get the game working with keyboard input (just to achieve MVP).\
	I will also add sprites to replace the simple graphics of circles, but again, this comes after.\
\
	Algorithmic Plan - One algorithm that I achieved is path drawing. This takes every point I specify for the path (eventually will be randomly generated) and connects them all with a line. Then, each point on the line has a circle drawn on it with radius 20. This is not too complex but involves a lot of edge case inclusion, like vertical lines, or diagonal slopes.\
	Another algorithm I achieved is collision / overlap detection for the turrets. This, using the radius values and x/y values of all the turrets and an algorithm that is constantly repeating that detects whether two circles are overlapping (based on center points and radii) tells if there is overlap. This prevents a new turret from being placed. I used the circle overlap detection on every circle that comprises the path (all 600 of them, one circle for each x value). This one was pretty complex, I think it may be one of the more complicated methods I have so far.\
	I need to include the ability of having balloons generate at the start, and follow down the path provided. I don\'92t think this will be too complicated.\
	I also need to use the circle overlap function again to tell when the balloons enter the bounds of a turret\'92s range, and when the turret should begin shooting. This is two algorithms, but they are intertwined. I think this will be the hardest part of the algorithm, because it includes many smaller things. Once I include sprites, rotation will be involved, as well as one balloon being hit per turret at a time. Also, the turrets need to stop attacking once balloons are out of range.\
\
	Timeline - I have a lot of features already that I listed above, but I plan on having all of the base features complete by TP2. Essentially, the game will be playable with keyboard input and cursor by TP2. I\'92ll try to also get the randomized path feature by then, but if not possible then I will work towards that for final submission. For the final submission, I will make the game more user friendly by using sprites, better graphics, audio, and buttons. The final game should be able to be played with mostly mouse input (cursor and clicking buttons).\
\
	Version Control - At the moment, each TP file is a separate python file. I think I will continue this, system, but also saving a new version of the tp file every time I achieve a new algorithmic checkpoint (once I satisfy one of the algorithms I described above). Also automatically backs up to OneDrive :) See \'93Version Control Plan.png\'94\
\
	Module List - At the moment, I\'92m not using any external modules besides cmu112graphics. However, I want a way to implement audio once I hit MVP - if I can do it without any modules, that would be perfect, but a quick search on the internet says that using something like PyGame (even though it isn\'92t allowed) makes it easier. I haven\'92t learned it yet so I can\'92t say anything for sure but if I do decide to use Pygame, it\'92s after I hit MVP (TP2) and I\'92ll let Mihika or another TA know for a tech demo. But this isn\'92t likely.\
	\
TP2 Update:\
	I think in terms of TP2, I might potentially reconsider my UI. I don\'92t think I\'92ll focus on having buttons/ a graphical way to add towers to the game. It certainly it nice, but again, this is something I\'92ll focus on after completely finishing off the entire game. This is the same with replacing the turrets with graphical icons: I\'92ll only do this if I can finish the base game well, looking relatively neat with basic cmu112graphics. \
	Random path generation seems doable, but it\'92s tough. I don\'92t have it entirely, I have a function pathGeneratior() that sort of does something, but it\'92s really buggy and I\'92m not going to use it until it\'92s smoother and not buggy.\
	I was able to get a lot of algorithms really well. For example, tower radius detection and attacking, as well as balloon adding to the path.\
\
TP3 Update:\
	As I said in TP2, I ended up not having buttons or mouseButton control for placing turrets. I think the UI is still clean without it. I also kept the turrets as is with the circles and fill colors, although I did use images for the background and Kosbie balloon and Taylor turret.\
	I think I got a good implementation of random path generation. This took me much longer than I expected: pretty much most of the 15 hours I worked between TP2 and TP3 went to attempting various different implementations of this, with eventually sticking with the system I have now.\
	The way this works is that each row and column is hardcoded on a 6x6 grid. The algorithm starts at (0,0), randomly goes either horizontally or vertically to another point, and then based on whether it moved horizontally or vertically, it removes the points that the path drawer goes over, to prevent balloons from piling or vertices from overlapping. It\'92s okay if paths overlap (and if anything, I want this since it allows for interesting loops on the map), but if vertices overlap then the game will break, since slope calculation for balloon movement on the path will no longer work. I\'92m satisfied with this implementation.\
	I also decided not to have turret upgrade capabilities towards the end.}